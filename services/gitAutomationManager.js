const { exec } = require('child_process');
const util = require('util');
const path = require('path');
const fs = require('fs');
const os = require('os');

const execAsync = util.promisify(exec);
const fsPromises = fs.promises;

function formatList(values) {
    if (!Array.isArray(values) || values.length === 0) {
        return 'None';
    }
    return values.map(value => String(value).trim()).filter(Boolean).join(', ');
}

function coerceIsoDate(value) {
    if (!value) {
        return new Date().toISOString();
    }
    try {
        return new Date(value).toISOString();
    } catch {
        return new Date().toISOString();
    }
}

class GitAutomationManager {
    constructor() {
        this.rootDir = process.cwd();
        this.enabled = true; // Can be toggled via environment configuration
    }

    async isGitRepository() {
        try {
            await execAsync('git rev-parse --git-dir', { cwd: this.rootDir });
            return true;
        } catch {
            return false;
        }
    }

    async getGitStatus() {
        try {
            const { stdout } = await execAsync('git status --porcelain', { cwd: this.rootDir });
            const changes = stdout
                .split('\n')
                .map(line => line.trim())
                .filter(Boolean);
            return {
                hasChanges: changes.length > 0,
                changes
            };
        } catch (error) {
            return { hasChanges: false, changes: [], error: error.message };
        }
    }

    async getCurrentBranch() {
        try {
            const { stdout } = await execAsync('git branch --show-current', { cwd: this.rootDir });
            return stdout.trim();
        } catch (error) {
            console.error('Error getting current branch:', error);
            return null;
        }
    }

    async stageAllChanges() {
        await execAsync('git add -A', { cwd: this.rootDir });
    }

    async commitWithMessage(message) {
        const tmpDir = await fsPromises.mkdtemp(path.join(os.tmpdir(), 'opnix-commit-'));
        const commitFile = path.join(tmpDir, 'message.txt');
        await fsPromises.writeFile(commitFile, `${message.trim()}\n`, 'utf8');

        try {
            await execAsync(`git commit -F "${commitFile}"`, { cwd: this.rootDir });
        } finally {
            await fsPromises.rm(commitFile, { force: true }).catch(() => {});
            await fsPromises.rm(tmpDir, { force: true, recursive: true }).catch(() => {});
        }
    }

    generateTicketCommitMessage(ticket) {
        const title = ticket.title || `Ticket ${ticket.id}`;
        const summary = ticket.completionSummary || 'Ticket complete';
        const updatedAt = coerceIsoDate(ticket.completedAt || ticket.updated);

        return `Ticket: ${title}\n\n${summary}\n\nTicket-ID: ${ticket.id}\nStatus: ${ticket.status}\nPriority: ${ticket.priority || 'unspecified'}\nModules: ${formatList(ticket.modules)}\nCompleted-At: ${updatedAt}\n\n Generated by Opnix Git Automation\nCo-Authored-By: Claude <noreply@anthropic.com>`;
    }

    generateFeatureCommitMessage(feature, { mergeTarget } = {}) {
        const title = feature.title || `Feature ${feature.id}`;
        const summary = feature.completionSummary || feature.description || 'Feature complete';
        const updatedAt = coerceIsoDate(feature.completedAt || feature.updated);
        const branchLine = feature.git?.branchName || feature.branchName
            ? `Branch: ${feature.git?.branchName || feature.branchName}\n`
            : '';
        const mergeLine = mergeTarget ? `Merge-Target: ${mergeTarget}\n` : '';

        return `Feature: ${title}\n\n${summary}\n\nFeature-ID: ${feature.id}\nStatus: ${feature.status}\nModule: ${feature.moduleId || 'unspecified'}\n${branchLine}${mergeLine}Completed-At: ${updatedAt}\n\n Generated by Opnix Git Automation\nCo-Authored-By: Claude <noreply@anthropic.com>`;
    }

    generateMilestoneCommitMessage(milestone, { dependencySummary, reason, actor } = {}) {
        const title = milestone.title || milestone.name || `Milestone ${milestone.id}`;
        const summary = milestone.completionSummary || 'Milestone complete';
        const updatedAt = coerceIsoDate(milestone.completedAt || milestone.updatedAt);
        const depend = dependencySummary || milestone.dependencySummary || {
            total: 0,
            satisfied: 0,
            blocked: 0,
            pending: 0,
            missing: 0,
            gatingProgress: milestone.progress || 0,
            status: 'clear'
        };
        const dependencyLines = `Dependencies: ${depend.total}\nSatisfied: ${depend.satisfied} | Pending: ${depend.pending} | Blocked: ${depend.blocked}\nGating-Progress: ${depend.gatingProgress}% (status: ${depend.status})`;

        const linkedTickets = formatList(milestone.linkedTickets);
        const linkedFeatures = formatList(milestone.linkedFeatures);
        const linkedModules = formatList(milestone.linkedModules || (milestone.linkedModule ? [milestone.linkedModule] : []));

        return `Milestone: ${title}\n\n${summary}\n\nMilestone-ID: ${milestone.id}\nStatus: ${milestone.status}\nProgress: ${milestone.progress}%\n${dependencyLines}\nLinked-Tickets: ${linkedTickets}\nLinked-Features: ${linkedFeatures}\nLinked-Modules: ${linkedModules}\nCompleted-At: ${updatedAt}\nReason: ${reason || 'roadmap:manual-edit'}\nActor: ${actor || 'automation'}\n\n Generated by Opnix Git Automation\nCo-Authored-By: Claude <noreply@anthropic.com>`;
    }

    generateAutoCompletionSummary(ticket, changes = []) {
        const { title, description, tags, modules } = ticket;

        const lines = [
            `Automatically completed: ${title}`,
            ''
        ];

        if (description) {
            lines.push(`Description: ${description}`, '');
        }

        if (Array.isArray(modules) && modules.length) {
            lines.push(`Affected modules: ${modules.join(', ')}`, '');
        }

        if (Array.isArray(tags) && tags.length) {
            lines.push(`Tags: ${tags.join(', ')}`, '');
        }

        if (Array.isArray(changes) && changes.length) {
            lines.push('Files changed:', ...changes.map(change => `- ${change}`), '');
        }

        lines.push('Completion automated via git workflow integration.');
        return lines.join('\n');
    }

    generateFeatureCompletionSummary(feature, changes = []) {
        const lines = [
            `Deployment complete: ${feature.title || feature.id}`,
            ''
        ];

        if (feature.description) {
            lines.push(`Summary: ${feature.description}`, '');
        }

        if (Array.isArray(feature.acceptanceCriteria) && feature.acceptanceCriteria.length) {
            lines.push('Acceptance criteria satisfied:', ...feature.acceptanceCriteria.map(item => `- ${item}`), '');
        }

        if (Array.isArray(changes) && changes.length) {
            lines.push('Files changed:', ...changes.map(change => `- ${change}`), '');
        }

        if (feature.git?.branchName || feature.branchName) {
            lines.push(`Feature branch: ${feature.git?.branchName || feature.branchName}`);
        }

        lines.push('Deployment captured by Opnix Git automation.');
        return lines.join('\n');
    }

    generateMilestoneCompletionSummary(milestone, { dependencySummary } = {}) {
        const summary = dependencySummary || milestone.dependencySummary || {};
        const lines = [
            `Milestone "${milestone.title || milestone.name || milestone.id}" reached completion.`,
            ''
        ];

        lines.push(`Progress snapshot: ${milestone.progress}% complete.`);

        if (summary.total) {
            lines.push(
                `Dependencies resolved: ${summary.satisfied}/${summary.total} (blocked: ${summary.blocked}, pending: ${summary.pending}, missing: ${summary.missing}).`,
                `Gating progress was limited to ${summary.gatingProgress}% (status: ${summary.status}).`
            );
        }

        const linkedTickets = formatList(milestone.linkedTickets);
        const linkedFeatures = formatList(milestone.linkedFeatures);
        const linkedModules = formatList(milestone.linkedModules || (milestone.linkedModule ? [milestone.linkedModule] : []));

        lines.push('', `Linked tickets: ${linkedTickets}`);
        lines.push(`Linked features: ${linkedFeatures}`);
        lines.push(`Linked modules: ${linkedModules}`);
        lines.push('', 'Generated automatically during roadmap completion.');

        return lines.join('\n');
    }

    async autoCommitTicket(ticket) {
        if (!this.enabled || !await this.isGitRepository()) {
            return { success: false, reason: 'Git not available or disabled' };
        }

        try {
            const status = await this.getGitStatus();
            if (!status.hasChanges) {
                return { success: false, reason: 'No changes to commit' };
            }

            if (!ticket.completionSummary || ticket.completionSummary.trim().length < 20) {
                ticket.completionSummary = this.generateAutoCompletionSummary(ticket, status.changes);
            }

            if (!ticket.completedAt) {
                ticket.completedAt = new Date().toISOString();
            }

            const commitMessage = this.generateTicketCommitMessage(ticket);
            await this.stageAllChanges();
            await this.commitWithMessage(commitMessage);

            return {
                success: true,
                commitMessage,
                changes: status.changes,
                branch: await this.getCurrentBranch()
            };
        } catch (error) {
            return {
                success: false,
                reason: error.message,
                error
            };
        }
    }

    async autoCommitFeature(feature, options = {}) {
        if (!this.enabled || !await this.isGitRepository()) {
            return { success: false, reason: 'Git not available or disabled' };
        }

        try {
            const status = await this.getGitStatus();
            if (!status.hasChanges) {
                return { success: false, reason: 'No changes to commit' };
            }

            if (!feature.completionSummary || feature.completionSummary.trim().length < 20) {
                feature.completionSummary = this.generateFeatureCompletionSummary(feature, status.changes);
            }

            if (!feature.completedAt) {
                feature.completedAt = new Date().toISOString();
            }

            const mergeTarget = options.targetBranch || feature.git?.targetBranch || 'main';
            const commitMessage = this.generateFeatureCommitMessage(feature, { mergeTarget });

            await this.stageAllChanges();
            await this.commitWithMessage(commitMessage);

            let mergeResult = null;
            if (options.merge !== false) {
                const branchName = options.branchName || feature.git?.branchName || feature.branchName;
                if (branchName) {
                    try {
                        mergeResult = await this.mergeFeatureBranch(branchName, mergeTarget);
                    } catch (mergeError) {
                        mergeResult = {
                            success: false,
                            reason: mergeError.message,
                            error: mergeError
                        };
                    }
                }
            }

            return {
                success: true,
                commitMessage,
                changes: status.changes,
                branch: await this.getCurrentBranch(),
                mergeResult
            };
        } catch (error) {
            return {
                success: false,
                reason: error.message,
                error
            };
        }
    }

    async autoCommitMilestone(milestone, options = {}) {
        if (!this.enabled || !await this.isGitRepository()) {
            return { success: false, reason: 'Git not available or disabled' };
        }

        try {
            const status = await this.getGitStatus();
            if (!status.hasChanges) {
                return { success: false, reason: 'No changes to commit' };
            }

            const dependencySummary = options.dependencySummary || milestone.dependencySummary;
            if (!milestone.completionSummary || milestone.completionSummary.trim().length < 20) {
                milestone.completionSummary = this.generateMilestoneCompletionSummary(milestone, { dependencySummary });
            }

            if (!milestone.completedAt) {
                milestone.completedAt = new Date().toISOString();
            }

            const commitMessage = this.generateMilestoneCommitMessage(milestone, {
                dependencySummary,
                reason: options.reason,
                actor: options.actor
            });

            await this.stageAllChanges();
            await this.commitWithMessage(commitMessage);

            return {
                success: true,
                commitMessage,
                changes: status.changes,
                branch: await this.getCurrentBranch()
            };
        } catch (error) {
            return {
                success: false,
                reason: error.message,
                error
            };
        }
    }

    async mergeFeatureBranch(featureBranch, targetBranch = 'main') {
        if (!this.enabled || !await this.isGitRepository()) {
            return { success: false, reason: 'Git not available or disabled' };
        }

        try {
            const currentBranch = await this.getCurrentBranch();

            await execAsync(`git checkout ${targetBranch}`, { cwd: this.rootDir });
            await execAsync(`git pull origin ${targetBranch}`, { cwd: this.rootDir });
            await execAsync(`git merge ${featureBranch} --no-ff`, { cwd: this.rootDir });
            await execAsync(`git branch -d ${featureBranch}`, { cwd: this.rootDir });

            return {
                success: true,
                mergedBranch: featureBranch,
                targetBranch,
                currentBranch: await this.getCurrentBranch(),
                previousBranch: currentBranch
            };
        } catch (error) {
            return {
                success: false,
                reason: error.message,
                error
            };
        }
    }

    async createFeatureBranch(item, type = 'feature') {
        if (!this.enabled || !await this.isGitRepository()) {
            return { success: false, reason: 'Git not available or disabled' };
        }

        try {
            const branchName = this.generateBranchName(item, type);
            await execAsync(`git checkout -b ${branchName}`, { cwd: this.rootDir });

            return {
                success: true,
                branchName,
                baseBranch: await this.getCurrentBranch()
            };
        } catch (error) {
            return {
                success: false,
                reason: error.message,
                error
            };
        }
    }

    generateBranchName(item, type = 'feature') {
        const { id, title } = item;
        const sanitizedTitle = (title || '')
            .toLowerCase()
            .replace(/[^a-z0-9\s-]/g, '')
            .replace(/\s+/g, '-')
            .substring(0, 30);

        return `${type}/${id}-${sanitizedTitle}`;
    }

    async getCommitHistory(since = '1 week ago') {
        try {
            const { stdout } = await execAsync(
                `git log --since="${since}" --pretty=format:"%h|%an|%ad|%s" --date=iso`,
                { cwd: this.rootDir }
            );

            return stdout.split('\n')
                .filter(line => line.trim())
                .map(line => {
                    const [hash, author, date, message] = line.split('|');
                    return { hash, author, date, message };
                });
        } catch (error) {
            console.error('Error getting recent commits:', error);
            return [];
        }
    }

    isAutomatedCommit(commitMessage) {
        return commitMessage.includes(' Generated by Opnix Git Automation') ||
            commitMessage.includes('Co-Authored-By: Claude');
    }
}

module.exports = new GitAutomationManager();
