# Storybook Workflow

Storybook surfaces Opnix components with the same real data used by the main application. It ships with both MOLE (default) and CANYON themes, matching the production UI without relying on mock payloads.

## Embedded Viewer

- The main Opnix console now hosts Storybook inside the **Storybook** tab. The iframe auto-applies the active MOLE or CANYON theme via `globals=theme:<name>` and inherits neon framing.
- Use the **Refresh** control in the tab to re-sync after regenerating stories or switching branches. Theme switches in the console instantly propagate without leaving the app.
- When Storybook isn’t running locally, the panel surfaces guidance instead of a blank iframe so operators know how to start the service. Use the in-app **Storybook** tab’s “Start Storybook” button to trigger `/api/storybook/start`, and the refresh control if you need to re-sync the iframe without reloading the entire console.

## Commands

```bash
# Regenerate Storybook stories from live detector outputs
npm run storybook:generate

# Run Storybook locally on http://localhost:6006
npm run storybook

# Build the static bundle (emits to storybook-static/)
npm run build-storybook
```

> **Note:** The static output is ignored by Git (`storybook-static/`). Publish the bundle separately if you need to host Storybook.

## Data Sources

- `data/tickets.json` – consumed directly by `TicketList` stories so the backlog matches the live workspace.
- Additional components should import from `data/` or call the existing services (`services/moduleDetector`, `services/interviewLoader`, etc.) rather than embedding placeholders.

## Structure

```
src/
  components/
    TicketList.vue        # Reusable Vue component extracted from the Bugs tab
    Sidebar/
      SpecArchive.vue     # Spec archive summary used across the SPA
    Console/
      ClaudeConsole.vue   # Persistent command console
  stories/
    TicketList.stories.ts # Manual stories (kept when hand-crafted variants are needed)
    auto/
      TicketList.generated.stories.ts
      Console/ClaudeConsole.generated.stories.ts
      Sidebar/SpecArchive.generated.stories.ts
  theme/
    storybook.css         # Theme bridge shared with Storybook
    mole.css              # MOLE palette tokens
    canyon.css            # CANYON palette tokens
.storybook/
  main.ts                 # Storybook configuration (Vite builder)
  preview.ts              # Global decorators & theming
```

## Autogenerated Story Flow

- `scripts/generateStories.js` pulls detector exports, ticket data, and the interview blueprint to produce stories under `src/stories/auto/`.
- The generator is idempotent — run `npm run storybook:generate` whenever audits/interviews produce new data or components gain additional props.
- Generated stories carry the `autogenerated` tag and never rely on mock payloads; they read directly from `data/`, `spec/`, and `services/` outputs.
- Manual stories can coexist in `src/stories/` (outside `auto/`) for bespoke scenarios — the generator will not overwrite them.
- Each run mirrors the generated files into `.opnix/runtime/stories/` and updates `.opnix/runtime/index.json`, keeping the hidden runtime bundle aligned with Storybook.

## Extensibility Hooks

- `scripts/generateStories.js` is the orchestrator—extend `gatherContext()` to pull additional data sources (roadmaps, health scores) and surface them as args/controls.
- Use `buildComponentImportPath()` within the generator when introducing new auto-story directories so imports remain portable when mirrored into `.opnix/runtime/`.
- `.storybook/main.ts` accepts additional Vite plugins (e.g., MDX loaders, i18n transformers); register them inside `viteFinal` while keeping the runtime bundler in sync.
- `.storybook/preview.ts` decorators control theming and global providers; hook into the decorator array to mount feature flags, routers, or mock service workers.
- Runtime mirroring via `runtimeBundler.syncStoryFiles()` enables downstream automation—subscribe to `.opnix/runtime/index.json` updates to trigger publishing, regression tests, or design hand-offs.

## Adding New Stories

1. Extract the UI fragment into `src/components/YourComponent.vue`.
2. Feed the component with **real** data:
   - Import JSON from `data/`, or
   - Use loaders to call Opnix services (e.g., `services/moduleDetector.detectModules`).
3. Create `src/stories/YourComponent.stories.ts` and expose the variants you need.
4. Run `npm run storybook` and verify the component renders under both MOLE and CANYON themes using the toolbar toggle.

## CI (Suggested)

Add a GitHub Action similar to the stub below to guarantee Storybook builds during PRs:

```yaml
name: storybook
on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm install
      - run: npm run build-storybook
```

This ensures new components remain compatible with the real workspace data and MOLE design language.
